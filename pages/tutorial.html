<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基础教程 - Redis 学习教程</title>
    <meta name="description" content="Redis 基础教程，从入门到进阶">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="../index.html" class="navbar-brand">
                <i>🗃️</i> Redis 学习教程
            </a>
            <ul class="nav-menu">
                <li><a href="../index.html">首页</a></li>
                <li><a href="tutorial.html" class="active">基础教程</a></li>
                <li><a href="commands.html">命令参考</a></li>
                <li><a href="playground.html">交互演示</a></li>
            </ul>
        </div>
    </nav>

    <div class="container" id="tutorialPage">
        <div class="tutorial-layout">
            <aside class="sidebar">
                <h3>📚 教程目录</h3>
                <ul class="sidebar-nav">
                    <li><a href="#intro" class="active">1. Redis 简介</a></li>
                    <li><a href="#install">2. 安装与配置</a></li>
                    <li><a href="#basics">3. 基础概念</a></li>
                    <li><a href="#datatypes">4. 数据类型</a></li>
                    <li><a href="#messaging">5. 消息命令</a></li>
                    <li><a href="#persistence">6. 持久化</a></li>
                    <li><a href="#advanced">7. 高级特性</a></li>
                    <li><a href="#plugin">8. 插件编写</a></li>
                    <li><a href="#latest">9. 最新特性</a></li>
                    <li><a href="#redisearch">10. RediSearch</a></li>
                </ul>
            </aside>

            <main>
                <section id="intro" class="content-section">
                    <h2>📘 1. Redis 简介</h2>
                    <p class="lead">
                        Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，可以用作数据库、缓存和消息中间件。
                    </p>

                    <h3>什么是 Redis？</h3>
                    <p>
                        Redis 是一个基于键值对（Key-Value）的内存数据库，它支持多种数据结构，如字符串、哈希、列表、集合和有序集合。
                    </p>
                    <p>
                        Redis 以其高性能、丰富的数据结构和强大的功能而闻名，广泛应用于缓存、会话存储、排行榜、实时分析等场景。
                    </p>

                    <h3>Redis 的核心特点</h3>
                    <ul>
                        <li><strong>内存存储：</strong>所有数据存储在内存中，访问速度极快</li>
                        <li><strong>丰富数据类型：</strong>支持字符串、哈希、列表、集合、有序集合等</li>
                        <li><strong>原子操作：</strong>所有操作都是原子的，保证数据一致性</li>
                        <li><strong>持久化支持：</strong>RDB 和 AOF 两种持久化方式</li>
                        <li><strong>主从复制：</strong>支持数据复制，提高可用性</li>
                        <li><strong>高可用：</strong>支持哨兵和集群模式</li>
                    </ul>

                    <h3>应用场景</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                        <div style="background: #e3f2fd; padding: 1rem; border-radius: 4px;">
                            <h4>⚡ 缓存系统</h4>
                            <p>作为数据库查询结果的缓存，减轻数据库压力</p>
                        </div>
                        <div style="background: #e8f5e9; padding: 1rem; border-radius: 4px;">
                            <h4>👤 会话存储</h4>
                            <p>存储用户会话信息，支持分布式应用</p>
                        </div>
                        <div style="background: #fff3e0; padding: 1rem; border-radius: 4px;">
                            <h4>🏆 排行榜</h4>
                            <p>利用有序集合实现实时排行榜功能</p>
                        </div>
                        <div style="background: #e3f2fd; padding: 1rem; border-radius: 4px;">
                            <h4>💬 消息队列</h4>
                            <p>使用列表和发布/订阅实现消息队列</p>
                        </div>
                    </div>
                </section>

                <section id="install" class="content-section">
                    <h2>⬇️ 2. 安装与配置</h2>

                    <h3>Linux/Mac 安装</h3>
                    <div class="code-block">
# 使用 Homebrew 安装（Mac）
brew install redis

# 使用 apt 安装（Ubuntu/Debian）
sudo apt-get install redis-server

# 使用 yum 安装（CentOS/RHEL）
sudo yum install redis
                    </div>

                    <h3>启动 Redis</h3>
                    <div class="code-block">
# 启动 Redis 服务器
redis-server

# 使用配置文件启动
redis-server /path/to/redis.conf

# 连接到 Redis 客户端
redis-cli
                    </div>

                    <h3>Docker 安装</h3>
                    <div class="code-block">
# 拉取 Redis 镜像
docker pull redis

# 运行 Redis 容器
docker run -d -p 6379:6379 --name my-redis redis:latest
                    </div>
                </section>

                <section id="basics" class="content-section">
                    <h2>📖 3. 基础概念</h2>

                    <h3>键（Key）</h3>
                    <p>
                        Redis 中的键是二进制安全的，可以使用任何字符串作为键名。通常建议使用有意义且简洁的键名。
                    </p>
                    <div style="background: #f8f9fa; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>键命名建议：</strong>
                        <ul>
                            <li>使用冒号分隔不同层级：<code style="color: #667eea;">user:1001:profile</code></li>
                            <li>保持键名简洁但有意义</li>
                            <li>避免使用过长的键名</li>
                        </ul>
                    </div>

                    <h3>值（Value）</h3>
                    <p>
                        Redis 支持多种数据类型的值，每种类型都有其特定的用途和操作命令。
                    </p>

                    <h3>数据库</h3>
                    <p>
                        Redis 默认支持 16 个数据库（索引 0-15），可以使用 SELECT 命令切换数据库。
                    </p>
                    <div class="code-block">
# 切换到数据库 1
SELECT 1

# 查看当前数据库的键数量
DBSIZE
                    </div>
                </section>

                <section id="datatypes" class="content-section">
                    <h2>🎯 4. 数据类型</h2>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem;">
                        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="color: #667eea;">📝 字符串（String）</h3>
                            <p>最基本的数据类型，可以存储任何形式的数据，包括文本、数字、二进制数据等。</p>
                            <div class="code-block">
SET key value
GET key
INCR key
                            </div>
                        </div>

                        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="color: #27ae60;">#️⃣ 哈希（Hash）</h3>
                            <p>键值对集合，适合存储对象。一个哈希可以包含多个字段和值。</p>
                            <div class="code-block">
HSET key field value
HGET key field
HGETALL key
                            </div>
                        </div>

                        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="color: #f39c12;">📋 列表（List）</h3>
                            <p>有序的字符串集合，支持在列表的两端进行插入和删除操作。</p>
                            <div class="code-block">
LPUSH key value
RPUSH key value
LRANGE key 0 -1
                            </div>
                        </div>

                        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="color: #e74c3c;">🔢 集合（Set）</h3>
                            <p>无序不重复的字符串集合，支持集合间的交集、并集、差集操作。</p>
                            <div class="code-block">
SADD key member
SMEMBERS key
SINTER key1 key2
                            </div>
                        </div>

                        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="color: #3498db;">📊 有序集合（ZSet）</h3>
                            <p>有序的字符串集合，每个元素都关联一个分数，支持按分数范围查询。</p>
                            <div class="code-block">
ZADD key score member
ZRANGE key 0 -1
ZRANK key member
                            </div>
                        </div>

                        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="color: #9b59b6;">🎨 位图（Bitmap）</h3>
                            <p>基于字符串类型的位操作，可以高效的进行位级别的操作。</p>
                            <div class="code-block">
SETBIT key offset value
GETBIT key offset
BITCOUNT key
                            </div>
                        </div>

                        <div style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px;">
                            <h3 style="color: #e91e63;">📦 JSON（RedisJSON）</h3>
                            <p>原生 JSON 数据类型支持，允许在 Redis 中存储、查询和操作 JSON 文档。需要 RedisJSON 模块。</p>
                            <div class="code-block">
JSON.SET key $ '{"name":"Redis","version":7}'
JSON.GET key $
JSON.GET key $.name
JSON.DEL key $.version
JSON.ARRLEN key $.items
                            </div>
                        </div>
                    </div>
                </section>

                <section id="messaging" class="content-section">
                    <h2>💬 5. 消息命令</h2>

                    <p>Redis 提供了强大的消息传递机制，包括发布/订阅模式和流（Stream）数据结构，用于实现消息队列、实时通信等功能。</p>

                    <h3>发布/订阅（Pub/Sub）</h3>
                    <p>发布/订阅是一种消息通信模式，发送者（发布者）发送消息到频道，订阅者接收该频道的消息。</p>

                    <h4>基础命令</h4>
                    <div class="code-block">
# 发布消息到频道
PUBLISH channel "Hello World"

# 订阅一个或多个频道
SUBSCRIBE channel1 channel2

# 取消订阅
UNSUBSCRIBE channel

# 按模式订阅频道
PSUBSCRIBE news.*

# 按模式取消订阅
PUNSUBSCRIBE news.*
                    </div>

                    <h4>应用场景</h4>
                    <ul>
                        <li><strong>实时通知：</strong>用户在线状态、系统告警等</li>
                        <li><strong>实时聊天：</strong>多房间聊天室</li>
                        <li><strong>日志聚合：</strong>多个服务发送日志到中央频道</li>
                        <li><strong>事件广播：</strong>微服务间的事件通知</li>
                    </ul>

                    <h3>流（Stream）</h3>
                    <p>Stream 是 Redis 5.0 引入的日志型数据结构，类似于 Kafka，用于消息队列和事件溯源。</p>

                    <h4>基础命令</h4>
                    <div class="code-block">
# 向流添加消息
XADD mystream * field1 value1 field2 value2

# 读取流中的消息
XRANGE mystream - +

# 消费者组读取消息
XREADGROUP GROUP group1 consumer1 COUNT 1 STREAMS mystream &gt;

# 创建消费者组
XGROUP CREATE mystream group1 0

# 确认消息处理完成
XACK mystream group1 message_id

# 获取消费者组信息
XINFO GROUPS mystream

# 获取消费者信息
XINFO CONSUMERS mystream group1
                    </div>

                    <h4>Stream 特性</h4>
                    <ul>
                        <li><strong>消息持久化：</strong>消息会被持久化，支持重放</li>
                        <li><strong>消费者组：</strong>支持多个消费者协作处理消息</li>
                        <li><strong>消息确认：</strong>支持 ACK 机制，确保消息被正确处理</li>
                        <li><strong>消费者偏移量：</strong>记录每个消费者的消费进度</li>
                        <li><strong>消息阻塞读取：</strong>支持阻塞读取新消息</li>
                    </ul>

                    <h4>应用场景</h4>
                    <ul>
                        <li><strong>消息队列：</strong>可靠的消息传递和处理</li>
                        <li><strong>事件溯源：</strong>记录系统状态变更历史</li>
                        <li><strong>实时分析：</strong>实时数据处理和监控</li>
                        <li><strong>任务队列：</strong>异步任务处理</li>
                    </ul>

                    <h3>列表作为消息队列</h3>
                    <p>在引入 Stream 之前，Redis 列表常被用作简单的消息队列。</p>

                    <h4>基础命令</h4>
                    <div class="code-block">
# 生产者：发送消息到队列头部
LPUSH queue "message1"

# 消费者：从队列尾部取出消息
BRPOP queue 0  # 阻塞式读取

# 获取队列长度
LLEN queue

# 查看队列内容
LRANGE queue 0 -1
                    </div>

                    <h4>优缺点</h4>
                    <div style="background: #e3f2fd; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>优点：</strong>简单易用、高性能、支持阻塞读取
                    </div>
                    <div style="background: #fff3e0; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>缺点：</strong>不支持消费者组、消息不可重放、缺少确认机制
                    </div>

                    <h3>消息队列模式对比</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                        <tr style="background: #667eea; color: white;">
                            <th style="padding: 0.75rem; border: 1px solid #ddd;">特性</th>
                            <th style="padding: 0.75rem; border: 1px solid #ddd;">Pub/Sub</th>
                            <th style="padding: 0.75rem; border: 1px solid #ddd;">Stream</th>
                            <th style="padding: 0.75rem; border: 1px solid #ddd;">List</th>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">消息持久化</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">❌</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">✅</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">✅</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">消费者组</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">❌</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">✅</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">❌</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">消息确认</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">❌</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">✅</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">❌</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">消息重放</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">❌</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">✅</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">❌</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">实时性</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">使用复杂度</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐</td>
                        </tr>
                    </table>

                    <h3>最佳实践建议</h3>
                    <ul>
                        <li><strong>简单通知：</strong>使用 Pub/Sub，适合实时通知场景</li>
                        <li><strong>可靠消息传递：</strong>使用 Stream，支持消费者组和消息确认</li>
                        <li><strong>简单队列：</strong>使用 List，适合轻量级消息队列</li>
                        <li><strong>需要持久化和重放：</strong>优先选择 Stream</li>
                        <li><strong>需要多个消费者协作：</strong>使用 Stream 的消费者组功能</li>
                    </ul>
                </section>

                <section id="persistence" class="content-section">
                    <h2>💾 5. 持久化</h2>

                    <h3>RDB（Redis Database）</h3>
                    <p>
                        RDB 是 Redis 默认的持久化方式，它会在指定的时间间隔内生成数据集的时间点快照。
                    </p>
                    <div style="background: #e3f2fd; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>优点：</strong>文件紧凑，恢复速度快<br>
                        <strong>缺点：</strong>可能会丢失最后一次快照后的数据
                    </div>

                    <h3>AOF（Append Only File）</h3>
                    <p>
                        AOF 记录服务器接收到的每一个写操作命令，并在服务器启动时重新执行这些命令来恢复数据。
                    </p>
                    <div style="background: #fff3e0; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>优点：</strong>数据安全性更高，只丢失一秒数据<br>
                        <strong>缺点：</strong>文件体积较大，恢复速度较慢
                    </div>
                </section>

                <section id="advanced" class="content-section">
                    <h2>⚡ 6. 高级特性</h2>

                    <h3>事务</h3>
                    <p>
                        Redis 事务通过 MULTI、EXEC、DISCARD 和 WATCH 命令实现，保证一组命令的原子性执行。
                    </p>
                    <div class="code-block">
MULTI
SET key1 value1
SET key2 value2
EXEC
                    </div>

                    <h3>发布/订阅</h3>
                    <p>
                        Redis 提供了发布/订阅功能，可以实现消息的广播和接收。
                    </p>
                    <div class="code-block">
# 订阅频道
SUBSCRIBE channel

# 发布消息
PUBLISH channel "Hello Redis"
                    </div>

                    <h3>Lua 脚本</h3>
                    <p>
                        Redis 支持 Lua 脚本，可以在服务器端执行复杂的逻辑，保证原子性。
                    </p>
                    <div class="code-block">
EVAL "return redis.call('SET', KEYS[1], ARGV[1])&quot; 1 mykey myvalue
                    </div>
                </section>

                <section id="plugin" class="content-section">
                    <h2>🔧 8. 插件编写</h2>

                    <p>Redis 支持通过模块系统扩展其功能，开发者可以使用 C 语言或其他语言（通过 CFFI）编写自定义模块，添加新的数据类型、命令和功能。</p>

                    <h3>Redis 模块系统概述</h3>
                    <p>Redis 模块系统从 Redis 4.0 开始引入，允许开发者创建动态加载的扩展，扩展 Redis 的功能而无需修改 Redis 核心代码。</p>

                    <h4>模块的优势</h4>
                    <ul>
                        <li><strong>功能扩展：</strong>添加新的数据类型和命令</li>
                        <li><strong>性能优化：</strong>使用 C 语言实现高性能功能</li>
                        <li><strong>动态加载：</strong>无需重启 Redis 即可加载/卸载模块</li>
                        <li><strong>隔离性：</strong>模块运行在独立的环境中，不影响 Redis 核心稳定性</li>
                    </ul>

                    <h3>开发环境准备</h3>

                    <h4>安装 Redis 源码</h4>
                    <div class="code-block">
# 克隆 Redis 源码
git clone https://github.com/redis/redis.git
cd redis

# 编译 Redis
make

# 安装
sudo make install
                    </div>

                    <h4>安装开发工具</h4>
                    <div class="code-block">
# Ubuntu/Debian
sudo apt-get install build-essential

# macOS
xcode-select --install
                    </div>

                    <h3>创建第一个 Redis 模块</h3>

                    <h4>模块基本结构</h4>
                    <p>一个 Redis 模块需要包含以下关键组件：</p>
                    <ul>
                        <li><strong>模块初始化函数：</strong>在模块加载时调用</li>
                        <li><strong>命令定义：</strong>声明模块提供的命令</li>
                        <li><strong>命令实现函数：</strong>实现具体的命令逻辑</li>
                    </ul>

                    <h4>示例：简单的 Hello World 模块</h4>
                    <div class="code-block">
// helloworld.c
#include "redismodule.h"

// 命令实现函数
int HelloCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 1) {
        return RedisModule_WrongArity(ctx);
    }

    // 返回 "Hello, World!"
    RedisModule_ReplyWithSimpleString(ctx, "Hello, World!");
    return REDISMODULE_OK;
}

// 模块初始化函数
int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx, "helloworld", 1, REDISMODULE_APIVER_1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }

    // 注册命令
    if (RedisModule_CreateCommand(ctx, "hello", HelloCommand_RedisCommand, "readonly", 0, 0, 0) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}
                    </div>

                    <h4>编译模块</h4>
                    <div class="code-block">
# 编译为动态库
gcc -I /usr/local/include/redis/ -fPIC -shared -o helloworld.so helloworld.c

# 或者使用 Redis 提供的 Makefile
make
                    </div>

                    <h4>加载和使用模块</h4>
                    <div class="code-block">
# 启动 Redis 时加载模块
redis-server --loadmodule /path/to/helloworld.so

# 或者在运行时加载
redis-cli
127.0.0.1:6379&gt; MODULE LOAD /path/to/helloworld.so
OK

# 使用自定义命令
127.0.0.1:6379&gt; HELLO
"Hello, World!"

# 查看已加载的模块
127.0.0.1:6379&gt; MODULE LIST
1) 1) "name"
   2) "helloworld"
   3) "ver"
   4) (integer) 1
                    </div>

                    <h3>创建自定义数据类型</h3>

                    <h4>数据类型 API</h4>
                    <p>Redis 模块可以创建全新的数据类型，需要实现以下接口：</p>
                    <ul>
                        <li><strong>RDB 序列化/反序列化：</strong>数据持久化</li>
                        <li><strong>AOF 重写：</strong>命令日志记录</li>
                        <li><strong>内存使用统计：</strong>INFO 命令支持</li>
                        <li><strong>数据遍历：</strong>SCAN 命令支持</li>
                    </ul>

                    <h4>示例：简单的计数器数据类型</h4>
                    <div class="code-block">
// counter.c
#include "redismodule.h"
#include <stdlib.h>

// 数据类型结构
typedef struct {
    long long value;
} CounterObject;

// 创建新对象
CounterObject *createCounterObject(void) {
    CounterObject *co = RedisModule_Alloc(sizeof(CounterObject));
    co-&gt;value = 0;
    return co;
}

// 释放对象
void freeCounterObject(CounterObject *co) {
    RedisModule_Free(co);
}

// RDB 序列化
void counterRDBSave(RedisModuleIO *rdb, void *value) {
    CounterObject *co = value;
    RedisModule_SaveLongLong(rdb, co-&gt;value);
}

// RDB 反序列化
void *counterRDBLoad(RedisModuleIO *rdb, int encver) {
    CounterObject *co = createCounterObject();
    co-&gt;value = RedisModule_LoadLongLong(rdb);
    return co;
}

// AOF 重写
void counterAOFRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value) {
    CounterObject *co = value;
    RedisModule_EmitAOF(aof, "COUNTER.SET", "sl", key, co-&gt;value);
}

// 释放内存
void counterFree(void *value) {
    freeCounterObject(value);
}

// 创建命令
int CounterCreateCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) {
        return RedisModule_WrongArity(ctx);
    }

    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_WRITE);
    CounterObject *co = createCounterObject();
    
    RedisModule_ModuleTypeSetValue(key, CounterType, co);
    RedisModule_ReplyWithSimpleString(ctx, "OK");
    
    return REDISMODULE_OK;
}

// 设置命令
int CounterSetCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 3) {
        return RedisModule_WrongArity(ctx);
    }

    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_WRITE);
    if (RedisModule_KeyType(key) == REDISMODULE_KEYTYPE_EMPTY) {
        return RedisModule_ReplyWithError(ctx, "Counter does not exist");
    }

    CounterObject *co = RedisModule_ModuleTypeGetValue(key);
    long long value;
    RedisModule_StringToLongLong(argv[2], &amp;value);
    co-&gt;value = value;
    
    RedisModule_ReplyWithSimpleString(ctx, "OK");
    return REDISMODULE_OK;
}

// 获取命令
int CounterGetCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) {
        return RedisModule_WrongArity(ctx);
    }

    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_READ);
    if (RedisModule_KeyType(key) == REDISMODULE_KEYTYPE_EMPTY) {
        return RedisModule_ReplyWithError(ctx, "Counter does not exist");
    }

    CounterObject *co = RedisModule_ModuleTypeGetValue(key);
    RedisModule_ReplyWithLongLong(ctx, co-&gt;value);
    return REDISMODULE_OK;
}

// 数据类型定义
RedisModuleType *CounterType;

int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx, "counter", 1, REDISMODULE_APIVER_1) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }

    // 注册数据类型
    RedisModuleTypeMethods tm = {
        .version = REDISMODULE_TYPE_METHOD_VERSION,
        .rdb_load = counterRDBLoad,
        .rdb_save = counterRDBSave,
        .aof_rewrite = counterAOFRewrite,
        .free = counterFree
    };
    
    CounterType = RedisModule_CreateDataType(ctx, "CounterType", 0, &amp;tm);
    if (CounterType == NULL) return REDISMODULE_ERR;

    // 注册命令
    if (RedisModule_CreateCommand(ctx, "counter.create", CounterCreateCommand, "write", 0, 0, 0) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx, "counter.set", CounterSetCommand, "write", 0, 0, 0) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx, "counter.get", CounterGetCommand, "readonly", 0, 0, 0) == REDISMODULE_ERR) {
        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}
                    </div>

                    <h3>高级特性</h3>

                    <h4>通知和回调</h4>
                    <p>模块可以注册回调函数来响应 Redis 事件：</p>
                    <div class="code-block">
// 注册键空间通知回调
RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_STRING, keyspaceNotificationCallback);

// 注册模块命令回调
RedisModule_SetCommandInfoCallback(ctx, commandInfoCallback);
                    </div>

                    <h4>数据类型遍历</h4>
                    <p>为自定义数据类型实现 SCAN 支持：</p>
                    <div class="code-block">
// 实现 SCAN 遍历
void counterDigest(RedisModuleDigest *digest, void *value) {
    CounterObject *co = value;
    RedisModule_DigestAddLongLong(digest, co-&gt;value);
}

void counterFreeEffort(RedisModuleString *key, void *value) {
    // 返回释放对象所需的"代价"
    return 1;
}
                    </div>

                    <h4>集群支持</h4>
                    <p>模块可以在集群环境中工作：</p>
                    <div class="code-block">
// 检查集群模式
if (RedisModule_GetClusterNodeInfo(ctx, ...) == REDISMODULE_ERR) {
    // 集群模式处理
}
                    </div>

                    <h3>最佳实践</h3>

                    <h4>错误处理</h4>
                    <ul>
                        <li>始终检查 API 调用的返回值</li>
                        <li>使用 RedisModule_ReplyWithError 返回错误信息</li>
                        <li>在模块初始化时进行充分的参数验证</li>
                    </ul>

                    <h4>内存管理</h4>
                    <ul>
                        <li>使用 RedisModule_Alloc/RedisModule_Free 分配内存</li>
                        <li>实现正确的内存释放函数</li>
                        <li>避免内存泄漏</li>
                    </ul>

                    <h4>线程安全</h4>
                    <ul>
                        <li>Redis 模块运行在单线程环境中</li>
                        <li>避免使用全局变量</li>
                        <li>正确处理并发访问</li>
                    </ul>

                    <h4>性能优化</h4>
                    <ul>
                        <li>尽量减少不必要的内存分配</li>
                        <li>使用 RedisModule_Yield 处理长时间运行的操作</li>
                        <li>合理使用 RedisModule_Call 调用其他 Redis 命令</li>
                    </ul>

                    <h3>调试和测试</h3>

                    <h4>使用 Redis 的测试框架</h4>
                    <div class="code-block">
# 使用 Redis 的测试套件
./runtest --single unit/moduleapi

# 或使用 Redis 的模块测试工具
./runtest --single unit/type/set --valgrind
                    </div>

                    <h4>调试技巧</h4>
                    <ul>
                        <li>使用 RedisModule_Log 记录日志</li>
                        <li>使用 gdb 或 lldb 调试模块</li>
                        <li>使用 Valgrind 检测内存泄漏</li>
                    </ul>

                    <h3>发布和分发</h3>

                    <h4>模块打包</h4>
                    <div class="code-block">
# 创建 Makefile
CFLAGS = -I$(REDIS_PATH)/src -fPIC
LDFLAGS = -shared

all: mymodule.so

mymodule.so: mymodule.c
    $(CC) $(CFLAGS) -o $@ $&lt; $(LDFLAGS)
                    </div>

                    <h4>文档和示例</h4>
                    <ul>
                        <li>提供清晰的 README 文档</li>
                        <li>包含使用示例和最佳实践</li>
                        <li>提供 API 文档</li>
                    </ul>

                    <h3>常用模块参考</h3>
                    <ul>
                        <li><strong>RedisJSON：</strong>JSON 数据类型支持</li>
                        <li><strong>RediSearch：</strong>全文搜索引擎</li>
                        <li><strong>RedisTimeSeries：</strong>时间序列数据</li>
                        <li><strong>RedisBloom：</strong>概率数据结构</li>
                        <li><strong>RedisGraph：</strong>图数据库</li>
                    </ul>

                    <h3>学习资源</h3>
                    <ul>
                        <li><a href="https://redis.io/docs/manual/modules/" target="_blank">Redis Modules 官方文档</a></li>
                        <li><a href="https://github.com/RedisLabs/RedisModulesSDK" target="_blank">Redis Modules SDK</a></li>
                        <li><a href="https://github.com/RedisLabs/redisbloom" target="_blank">RedisBloom 源码</a></li>
                        <li><a href="https://github.com/RediSearch/RediSearch" target="_blank">RediSearch 源码</a></li>
                    </ul>
                </section>

                <section id="latest" class="content-section">
                    <h2>🚀 7. 最新特性</h2>

                    <h3>Redis 7.x 新特性</h3>
                    <p>Redis 7.x 版本引入了许多重要的新特性和改进，显著提升了性能和可用性。</p>

                    <h4>🔥 函数（Functions）</h4>
                    <p>Redis 7 引入了函数功能，这是 Lua 脚本的进化版本，提供了更好的性能和管理能力。</p>
                    <div class="code-block">
# 加载函数
FUNCTION LOAD "#!lua name=mylib \
local function myfunc(keys, args) \
    return redis.call('GET', keys[1]) \
end \
redis.register_function('myfunc', myfunc)"

# 执行函数
FCALL myfunc 1 mykey
                    </div>
                    <div style="background: #e3f2fd; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>优势：</strong>更好的性能、持久化、函数库管理、版本控制
                    </div>

                    <h4>📊 Redis Stack</h4>
                    <p>Redis Stack 是 Redis 的扩展模块，提供了现代应用所需的高级功能。</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1rem 0;">
                        <div style="background: #f8f9fa; padding: 1rem; border-radius: 4px;">
                            <h5>🔍 RedisJSON</h5>
                            <p>原生 JSON 数据类型支持</p>
                        </div>
                        <div style="background: #f8f9fa; padding: 1rem; border-radius: 4px;">
                            <h5>🔎 RediSearch</h5>
                            <p>全文搜索引擎</p>
                        </div>
                        <div style="background: #f8f9fa; padding: 1rem; border-radius: 4px;">
                            <h5>⏱️ RedisTimeSeries</h5>
                            <p>时间序列数据存储</p>
                        </div>
                        <div style="background: #f8f9fa; padding: 1rem; border-radius: 4px;">
                            <h5>📈 RedisBloom</h5>
                            <p>概率数据结构（布隆过滤器等）</p>
                        </div>
                    </div>

                    <h4>⚡ 性能优化</h4>
                    <p>Redis 7 在多个方面进行了性能优化：</p>
                    <ul>
                        <li><strong>更快的列表操作：</strong>使用 ListPack 替代 QuickList</li>
                        <li><strong>优化的哈希表：</strong>改进了哈希表的内存使用和性能</li>
                        <li><strong>更高效的过期键清理：</strong>改进了过期键的扫描和删除机制</li>
                        <li><strong>更好的集群性能：</strong>优化了集群槽的分配和迁移</li>
                    </ul>

                    <h4>🔐 安全增强</h4>
                    <p>Redis 7 增强了安全性功能：</p>
                    <ul>
                        <li><strong>ACL v2：</strong>改进的访问控制列表，支持更细粒度的权限管理</li>
                        <li><strong>TLS 1.3 支持：</strong>支持最新的 TLS 协议版本</li>
                        <li><strong>改进的密码策略：</strong>更强的密码强度要求</li>
                    </ul>

                    <h4>📦 新数据结构</h4>
                    <p>Redis 7 引入了一些新的数据结构改进：</p>
                    <ul>
                        <li><strong>ListPack：</strong>更紧凑的列表编码，减少内存使用</li>
                        <li><strong>Stream 增强：</strong>改进了消费者组和消费者管理</li>
                        <li><strong>HyperLogLog 改进：</strong>更精确的基数估计</li>
                    </ul>

                    <h4>🛠️ 运维改进</h4>
                    <p>Redis 7 提供了更好的运维工具和功能：</p>
                    <ul>
                        <li><strong>更完善的日志系统：</strong>结构化日志，支持 JSON 格式</li>
                        <li><strong>改进的监控指标：</strong>更详细的性能指标统计</li>
                        <li><strong>更好的调试工具：</strong>增强的命令和调试功能</li>
                        <li><strong>配置热重载：</strong>支持部分配置的动态更新</li>
                    </ul>

                    <h4>🌐 客户端改进</h4>
                    <p>Redis 7 对客户端协议进行了改进：</p>
                    <ul>
                        <li><strong>RESP3 协议：</strong>更高效的协议，支持更多数据类型</li>
                        <li><strong>客户端缓存：</strong>支持服务器辅助的客户端缓存</li>
                        <li><strong>推送/拉取模式：</strong>改进的键空间通知机制</li>
                    </ul>

                    <h3>Redis 8.x 展望</h3>
                    <p>Redis 8.x 将继续带来更多创新功能：</p>
                    <ul>
                        <li><strong>多线程架构：</strong>进一步改进并发性能</li>
                        <li><strong>更好的云原生支持：</strong>优化的容器化和云部署</li>
                        <li><strong>AI/ML 集成：</strong>支持机器学习工作负载</li>
                        <li><strong>持续的性能优化：</strong>针对大数据量的优化</li>
                    </ul>
                </section>

                <section id="redisearch" class="content-section">
                    <h2>🔎 10. RediSearch</h2>

                    <p class="lead">
                        RediSearch 是 Redis 的全文搜索引擎模块，为 Redis 提供了强大的搜索、索引和查询功能。
                    </p>

                    <h3>什么是 RediSearch？</h3>
                    <p>
                        RediSearch 是一个高性能的全文搜索引擎，基于 Redis 构建，支持中文分词、模糊搜索、聚合查询等高级功能。它可以在 Redis 中创建索引，对存储的数据进行快速搜索和检索。
                    </p>

                    <h3>RediSearch 的核心特性</h3>
                    <ul>
                        <li><strong>全文搜索：</strong>支持文本搜索、短语搜索、通配符搜索</li>
                        <li><strong>高性能：</strong>基于内存的索引，查询速度快</li>
                        <li><strong>中文支持：</strong>内置中文分词器，支持中文搜索</li>
                        <li><strong>聚合查询：</strong>支持分组、统计、排序等聚合操作</li>
                        <li><strong>实时索引：</strong>数据变更时自动更新索引</li>
                        <li><strong>高可用：</strong>支持 Redis 集群和主从复制</li>
                    </ul>

                    <h3>安装 RediSearch</h3>

                    <h4>使用 Docker 安装</h4>
                    <div class="code-block">
# 拉取包含 RediSearch 的 Redis 镜像
docker pull redis/redis-stack-server:latest

# 运行容器
docker run -d -p 6379:6379 --name redis-stack redis/redis-stack-server:latest
                    </div>

                    <h4>使用源码编译</h4>
                    <div class="code-block">
# 克隆 RediSearch 仓库
git clone https://github.com/RediSearch/RediSearch.git
cd RediSearch

# 编译模块
make setup
make build

# 加载模块到 Redis
redis-server --loadmodule ./build/search/redisearch.so
                    </div>

                    <h4>在运行时加载模块</h4>
                    <div class="code-block">
# 连接到 Redis
redis-cli

# 加载 RediSearch 模块
MODULE LOAD /path/to/redisearch.so

# 查看已加载的模块
MODULE LIST
                    </div>

                    <h3>创建索引</h3>

                    <h4>基础索引创建</h4>
                    <div class="code-block">
# 创建简单索引
FT.CREATE myindex ON HASH PREFIX 1 user: SCHEMA name TEXT age NUMERIC
                    </div>

                    <h4>完整索引配置</h4>
                    <div class="code-block">
# 创建包含多种字段的索引
FT.CREATE products_idx ON HASH PREFIX 1 product: SCHEMA
  title TEXT WEIGHT 5.0
  description TEXT
  price NUMERIC
  category TAG
  in_stock NUMERIC
  created_at NUMERIC SORTABLE
                    </div>

                    <h4>索引字段类型</h4>
                    <ul>
                        <li><strong>TEXT：</strong>文本字段，支持全文搜索</li>
                        <li><strong>NUMERIC：</strong>数值字段，支持范围查询和排序</li>
                        <li><strong>TAG：</strong>标签字段，支持精确匹配和集合操作</li>
                        <li><strong>GEOSHAPE：</strong>地理形状字段，支持地理空间查询</li>
                        <li><strong>VECTOR：</strong>向量字段，支持向量相似度搜索</li>
                    </ul>

                    <h3>添加数据</h3>

                    <h4>使用 HSET 添加数据</h4>
                    <div class="code-block">
# 添加用户数据
HSET user:1 name "张三" age 25 email "zhangsan@example.com"
HSET user:2 name "李四" age 30 email "lisi@example.com"
HSET user:3 name "王五" age 28 email "wangwu@example.com"

# 添加产品数据
HSET product:1 title "智能手机" description "高性能智能手机" price 3999 category "电子产品" in_stock 100
HSET product:2 title "笔记本电脑" description "轻薄便携笔记本" price 6999 category "电子产品" in_stock 50
HSET product:3 title "运动鞋" description "舒适耐穿运动鞋" price 599 category "服装" in_stock 200
                    </div>

                    <h3>搜索查询</h3>

                    <h4>基础搜索</h4>
                    <div class="code-block">
# 简单文本搜索
FT.SEARCH myindex "张三"

# 搜索多个关键词
FT.SEARCH myindex "张三 OR 李四"

# 短语搜索
FT.SEARCH products_idx "智能手机"
                    </div>

                    <h4>高级搜索</h4>
                    <div class="code-block">
# 带条件的搜索
FT.SEARCH products_idx "@title:智能 @price:[3000 5000]"

# 使用通配符
FT.SEARCH products_idx "@title:智*"

# 模糊搜索
FT.SEARCH products_idx "%智能%"
                    </div>

                    <h4>数值范围查询</h4>
                    <div class="code-block">
# 价格范围查询
FT.SEARCH products_idx "@price:[500 1000]"

# 年龄范围查询
FT.SEARCH myindex "@age:[25 30]"
                    </div>

                    <h4>标签查询</h4>
                    <div class="code-block">
# 单个标签查询
FT.SEARCH products_idx "@category:{电子产品}"

# 多个标签查询
FT.SEARCH products_idx "@category:{电子产品 | 服装}"

# 排除标签
FT.SEARCH products_idx "@category:{-配件}"
                    </div>

                    <h4>布尔查询</h4>
                    <div class="code-block">
# AND 查询
FT.SEARCH products_idx "@title:智能 @category:{电子产品}"

# OR 查询
FT.SEARCH products_idx "@title:智能 | @title:电脑"

# NOT 查询
FT.SEARCH products_idx "@title:智能 -@category:{配件}"

# 复杂布尔查询
FT.SEARCH products_idx "(@title:智能 | @title:电脑) @price:[0 5000]"
                    </div>

                    <h4>排序和分页</h4>
                    <div class="code-block">
# 按价格升序排序
FT.SEARCH products_idx "*" SORTBY price ASC

# 按价格降序排序
FT.SEARCH products_idx "*" SORTBY price DESC

# 分页查询
FT.SEARCH products_idx "*" LIMIT 0 10

# 排序和分页结合
FT.SEARCH products_idx "*" SORTBY price DESC LIMIT 0 10
                    </div>

                    <h3>聚合查询</h3>

                    <h4>基础聚合</h4>
                    <div class="code-block">
# 按类别分组统计
FT.AGGREGATE products_idx "*" GROUPBY 1 @category REDUCE COUNT 0 AS count

# 计算平均价格
FT.AGGREGATE products_idx "*" REDUCE AVG 1 @price AS avg_price
                    </div>

                    <h4>复杂聚合</h4>
                    <div class="code-block">
# 按类别分组，计算数量和平均价格
FT.AGGREGATE products_idx "*"
  GROUPBY 1 @category
  REDUCE COUNT 0 AS count
  REDUCE AVG 1 @price AS avg_price
  REDUCE SUM 1 @price AS total_price
  SORTBY count DESC
                    </div>

                    <h4>过滤和排序</h4>
                    <div class="code-block">
# 带过滤条件的聚合
FT.AGGREGATE products_idx "@category:{电子产品}"
  GROUPBY 1 @category
  REDUCE COUNT 0 AS count
  REDUCE AVG 1 @price AS avg_price

# 多级排序
FT.AGGREGATE products_idx "*"
  GROUPBY 1 @category
  REDUCE COUNT 0 AS count
  SORTBY count DESC avg_price ASC
                    </div>

                    <h3>中文分词</h3>

                    <h4>使用中文分词器</h4>
                    <div class="code-block">
# 创建支持中文的索引
FT.CREATE articles_idx ON HASH PREFIX 1 article: SCHEMA
  title TEXT
  content TEXT LANGUAGE chinese
  tags TAG
                    </div>

                    <h4>中文搜索示例</h4>
                    <div class="code-block">
# 添加中文文章
HSET article:1 title "Redis 教程" content "Redis 是一个高性能的键值数据库" tags "数据库 缓存"
HSET article:2 title "搜索引擎" content "全文搜索引擎支持中文分词" tags "搜索 中文"

# 中文搜索
FT.SEARCH articles_idx "数据库"
FT.SEARCH articles_idx "中文分词"
FT.SEARCH articles_idx "@title:{Redis}"
                    </div>

                    <h3>索引管理</h3>

                    <h4>查看索引信息</h4>
                    <div class="code-block">
# 列出所有索引
FT._LIST

# 查看索引详情
FT.INFO myindex

# 查看索引的字段
FT.PRODUCTS_IDX
                    </div>

                    <h4>删除索引</h4>
                    <div class="code-block">
# 删除索引
FT.DROPINDEX myindex

# 删除索引及其关联的文档
FT.DROPINDEX myindex DD
                    </div>

                    <h4>重建索引</h4>
                    <div class="code-block">
# 重建索引
FT.DROPINDEX myindex
FT.CREATE myindex ON HASH PREFIX 1 user: SCHEMA name TEXT age NUMERIC
                    </div>

                    <h3>性能优化</h3>

                    <h4>索引优化建议</h4>
                    <ul>
                        <li><strong>合理选择字段：</strong>只为需要搜索的字段创建索引</li>
                        <li><strong>使用字段权重：</strong>为重要字段设置更高的权重</li>
                        <li><strong>限制结果数量：</strong>使用 LIMIT 分页返回结果</li>
                        <li><strong>避免通配符开头的查询：</strong>影响性能</li>
                        <li><strong>使用 SORTABLE 字段：</strong>提高排序性能</li>
                    </ul>

                    <h4>查询优化技巧</h4>
                    <div class="code-block">
# 使用 NOCONTENT 只返回 ID，减少数据传输
FT.SEARCH products_idx "@title:智能" NOCONTENT

# 使用 RETURN 指定返回字段
FT.SEARCH products_idx "@title:智能" RETURN 2 title price

# 使用 SCORER 指定评分算法
FT.SEARCH products_idx "@title:智能" SCORER BM25
                    </div>

                    <h3>应用场景</h3>

                    <h4>电商搜索</h4>
                    <div style="background: #e3f2fd; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>功能：</strong>商品搜索、分类筛选、价格排序、关键词高亮
                    </div>

                    <h4>内容搜索</h4>
                    <div style="background: #e8f5e9; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>功能：</strong>文章搜索、全文检索、相关推荐
                    </div>

                    <h4>日志分析</h4>
                    <div style="background: #fff3e0; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>功能：</strong>日志搜索、错误过滤、统计分析
                    </div>

                    <h4>用户搜索</h4>
                    <div style="background: #f3e5f5; padding: 1rem; border-radius: 4px; margin: 1rem 0;">
                        <strong>功能：</strong>用户查找、条件筛选、实时匹配
                    </div>

                    <h3>RediSearch vs 传统搜索引擎</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                        <tr style="background: #667eea; color: white;">
                            <th style="padding: 0.75rem; border: 1px solid #ddd;">特性</th>
                            <th style="padding: 0.75rem; border: 1px solid #ddd;">RediSearch</th>
                            <th style="padding: 0.75rem; border: 1px solid #ddd;">Elasticsearch</th>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">性能</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">部署复杂度</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">中文支持</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐⭐</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">聚合查询</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐⭐</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">内存占用</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid #ddd; background: #f8f9fa;">实时性</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐⭐</td>
                            <td style="padding: 0.75rem; border: 1px solid #ddd;">⭐⭐⭐⭐</td>
                        </tr>
                    </table>

                    <h3>最佳实践</h3>
                    <ul>
                        <li><strong>合理设计索引：</strong>根据查询需求设计索引结构</li>
                        <li><strong>使用合适的字段类型：</strong>TEXT 用于文本，NUMERIC 用于数值，TAG 用于分类</li>
                        <li><strong>控制索引大小：</strong>避免创建过多的索引字段</li>
                        <li><strong>使用缓存：</strong>对热点查询结果进行缓存</li>
                        <li><strong>监控性能：</strong>定期检查索引性能和查询响应时间</li>
                    </ul>

                    <h3>学习资源</h3>
                    <ul>
                        <li><a href="https://redis.io/docs/stack/search/" target="_blank">RediSearch 官方文档</a></li>
                        <li><a href="https://github.com/RediSearch/RediSearch" target="_blank">RediSearch GitHub 仓库</a></li>
                        <li><a href="https://redis.io/docs/stack/search/quick_start/" target="_blank">RediSearch 快速入门</a></li>
                    </ul>
                </section>

                <div style="text-align: center; margin-top: 3rem;">
                    <a href="commands.html" class="btn btn-primary" style="display: inline-flex; align-items: center; gap: 0.5rem;">
                        📋 继续学习命令参考
                    </a>
                </div>
            </main>
        </div>
    </div>

    <script src="../js/script.js"></script>
</body>
</html>